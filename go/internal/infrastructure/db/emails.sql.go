// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: emails.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createEmail = `-- name: CreateEmail :execresult
INSERT INTO emails (
    user_id,
    gmail_message_id,
    sender_email,
    subject,
    body_preview,
    received_at,
    is_notified
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type CreateEmailParams struct {
	UserID         string         `db:"user_id" json:"user_id"`
	GmailMessageID string         `db:"gmail_message_id" json:"gmail_message_id"`
	SenderEmail    string         `db:"sender_email" json:"sender_email"`
	Subject        sql.NullString `db:"subject" json:"subject"`
	BodyPreview    sql.NullString `db:"body_preview" json:"body_preview"`
	ReceivedAt     time.Time      `db:"received_at" json:"received_at"`
	IsNotified     sql.NullBool   `db:"is_notified" json:"is_notified"`
}

func (q *Queries) CreateEmail(ctx context.Context, arg CreateEmailParams) (sql.Result, error) {
	return q.exec(ctx, q.createEmailStmt, createEmail,
		arg.UserID,
		arg.GmailMessageID,
		arg.SenderEmail,
		arg.Subject,
		arg.BodyPreview,
		arg.ReceivedAt,
		arg.IsNotified,
	)
}

const deleteEmailsByUserID = `-- name: DeleteEmailsByUserID :exec
DELETE FROM emails
WHERE user_id = ?
`

func (q *Queries) DeleteEmailsByUserID(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.deleteEmailsByUserIDStmt, deleteEmailsByUserID, userID)
	return err
}

const getEmailByGmailMessageID = `-- name: GetEmailByGmailMessageID :one
SELECT id, user_id, gmail_message_id, sender_email, subject, body_preview, received_at, is_notified, created_at, updated_at FROM emails
WHERE gmail_message_id = ?
LIMIT 1
`

func (q *Queries) GetEmailByGmailMessageID(ctx context.Context, gmailMessageID string) (Email, error) {
	row := q.queryRow(ctx, q.getEmailByGmailMessageIDStmt, getEmailByGmailMessageID, gmailMessageID)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GmailMessageID,
		&i.SenderEmail,
		&i.Subject,
		&i.BodyPreview,
		&i.ReceivedAt,
		&i.IsNotified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmailsByUserID = `-- name: GetEmailsByUserID :many
SELECT id, user_id, gmail_message_id, sender_email, subject, body_preview, received_at, is_notified, created_at, updated_at FROM emails
WHERE user_id = ?
ORDER BY received_at DESC
`

func (q *Queries) GetEmailsByUserID(ctx context.Context, userID string) ([]Email, error) {
	rows, err := q.query(ctx, q.getEmailsByUserIDStmt, getEmailsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GmailMessageID,
			&i.SenderEmail,
			&i.Subject,
			&i.BodyPreview,
			&i.ReceivedAt,
			&i.IsNotified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEmails = `-- name: GetRecentEmails :many
SELECT id, user_id, gmail_message_id, sender_email, subject, body_preview, received_at, is_notified, created_at, updated_at FROM emails
WHERE user_id = ? AND received_at >= ?
ORDER BY received_at DESC
`

type GetRecentEmailsParams struct {
	UserID     string    `db:"user_id" json:"user_id"`
	ReceivedAt time.Time `db:"received_at" json:"received_at"`
}

func (q *Queries) GetRecentEmails(ctx context.Context, arg GetRecentEmailsParams) ([]Email, error) {
	rows, err := q.query(ctx, q.getRecentEmailsStmt, getRecentEmails, arg.UserID, arg.ReceivedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GmailMessageID,
			&i.SenderEmail,
			&i.Subject,
			&i.BodyPreview,
			&i.ReceivedAt,
			&i.IsNotified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnnotifiedEmailsByUserID = `-- name: GetUnnotifiedEmailsByUserID :many
SELECT id, user_id, gmail_message_id, sender_email, subject, body_preview, received_at, is_notified, created_at, updated_at FROM emails
WHERE user_id = ? AND is_notified = false
ORDER BY received_at DESC
`

func (q *Queries) GetUnnotifiedEmailsByUserID(ctx context.Context, userID string) ([]Email, error) {
	rows, err := q.query(ctx, q.getUnnotifiedEmailsByUserIDStmt, getUnnotifiedEmailsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GmailMessageID,
			&i.SenderEmail,
			&i.Subject,
			&i.BodyPreview,
			&i.ReceivedAt,
			&i.IsNotified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailAsNotified = `-- name: MarkEmailAsNotified :exec
UPDATE emails
SET is_notified = true,
    updated_at = CURRENT_TIMESTAMP
WHERE gmail_message_id = ?
`

func (q *Queries) MarkEmailAsNotified(ctx context.Context, gmailMessageID string) error {
	_, err := q.exec(ctx, q.markEmailAsNotifiedStmt, markEmailAsNotified, gmailMessageID)
	return err
}

const updateEmailNotified = `-- name: UpdateEmailNotified :exec
UPDATE emails
SET is_notified = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateEmailNotifiedParams struct {
	IsNotified sql.NullBool `db:"is_notified" json:"is_notified"`
	ID         uint64       `db:"id" json:"id"`
}

func (q *Queries) UpdateEmailNotified(ctx context.Context, arg UpdateEmailNotifiedParams) error {
	_, err := q.exec(ctx, q.updateEmailNotifiedStmt, updateEmailNotified, arg.IsNotified, arg.ID)
	return err
}
